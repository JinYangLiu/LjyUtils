### 一 ‘热修复技术介绍’
- 重新发布版本代价大，成本高，不及时，用户体验差，对此有几种解决方案：
    1. Hybird，将需要经常变更的业务逻辑以h5的方式独立出来，但需要
    用到前端开发，人工或学习成本高，且需要对原先的逻辑进行合适的抽象
    和转换，且无法对h5以外的其他代码进行修复；
    2. 插件化，移植成本高，需要学习整套插件化工具，而且对老代码的改造
    很是费时费力；
    3. 热修复技术，将补丁上传到云端，app可以直接从云端下来补丁直接应用；
- 常见的热修复框架：腾讯qq空间的超级补丁，微信的Tinker，饿了么的Amigo，
美团的Robust，阿里的：手淘Dexposed->支付宝Andfix->阿里百川Hotfix
->手淘Sophix；（这本书主要是结合Sophix讲述的）

- 代码修复：
    1. 底层替换方案：
        - 限制多，但时效性好，加载轻快，立即见效；
        （Andfix主要就是这种）
        - 在已经加载了的类中直接替换掉原有方法，无法对原有类进行方法
        和字段的增减，因为这将破坏原有类的结构（引起索引变化）
        - 由于android是开源的，各手机厂商都可以对代码进行改造，以及
        android版本的迭代，导致底层ArtMethod结构的差异；
    2. 类加载方案：
        - 限制少，修复范围广，但时效性差，需要重新冷启动才能生效；
        （Tinker主要就是这种，但对dex内容的比较粒度过细（方法和指令），
        性能消耗比较严重，较佳的粒度应该在类的维度，Sophix就是这样，并且
        重新编排了包中dex的顺序，classes.dex,classes2.dex..,可以看作是
        dex文件级别的类插桩方案,对旧包中的dex顺序进行打破重组）
        - app重新启动后让classLoader去加载新的类（因为android无法
        对一个类进行卸载，如果不重启，原来的类还在虚拟机中，无法加载新类），
        在还没走业务逻辑之前抢先加载补丁中的新类，这样后续访问这个类时，
        就会resolve为新类，从而达到热修复；

    3. Sophix：同时涵盖了上面两种方案，针对小修改，在底层替换方案限制范
    围内，就直接采用底层替换，否则使用类加载替换；还会再判断所运行的机型
    是否支持底层替换方案，否则就会使用类加载替换方案，达到最好的兼容性；

- 资源修复：
    - 目前市面上大部分资源热修复方案基本都参考了Instant Run的实现，
    其主要分两步：
        1. 构造一个新的AssetManager，并通过反射调用addAssetPath，把这个
        完整的新资源包加入到AssetManager中，这样就得到了一个含有所有新
        资源的AssetManager；
        2. 找到所有之前引用到原有AssetManager的地方，通过反射，把引用处
        替换为新AssetManager；
    - Sophix: 另辟蹊径，构造了一个package id为0x66的资源包(原有资源包为
    0x7f），此包只包含改变了的资源项，然后直接在原有的AssetManager中
    addAssetPath这个包就可以了;

- so库修复：
    - 本质：对native方法的修复和替换；
    - Sophix：采用类似类修复反射注入方式，把补丁so库的路径插入到
    nativeLibraryDirectories数组的最前面，达到加载so库时使用补丁so库；
    不用像某些其他方案需要手动替换系统的System.load来实现替换的目的;
