### 定义

- 数据结构：对计算机内存/磁盘中数据的一种安排，数据结构包括数组，栈，二叉树，哈希表等待
- 算法：对这些结构中的数据进行各种处理，如查找，排序等

### 常用数据结构的优缺点

- 数组
    - 优点：插入快，如果知道下标，可以非常快速的存取
    - 缺点：查找慢，删除慢，大小固定
- 有序数组
    - 查找比无需数组快
    - 插入慢，删除慢，大小固定
- 栈
    - 提供后进先出方式的存取
    - 存取其他项很慢
    - 更多参看 Stacker.java
- 队列
    - 提供先进先出方式的存取
    - 存取其他项很慢
    - 更多参看 Queue.java
- 链表
    - 插入快，删除快
    - 查找慢
    - 更多参看 Link.java
- 二叉树
    - 插入，查找，删除都很快
    - 删除算法复杂
- 红黑树
    - 插入，查找，删除都很快，树总是平衡的
    - 算法复杂
- 234树
    - 插入，查找，删除都很快，树总是平衡的，
    - 算法复杂
- 哈希表
    - 插入快，如果关键字已知则存取极快
    - 删除慢，如果关键字未知则存取很慢，对存储空间使用不充分
- 堆    
    - 插入，删除快，对最大数据项的存取快
    - 对其他数据项的存取慢
- 图
    - 对现实世界建模
    - 有些算法慢且复杂
    
- 以上除数组外，都可以被认为是抽象数据结构   

- 面向对象编程语言的产生，是由于面向过程语言在处理大型的复杂问题时的力不从心 
    - 程序与现实世界缺乏对应关系（对现实世界建模的无能为力）
    - 程序内部的结构出现了问题

- 抽象数据类型：Abstract Data Type ，简称ADT，用于指定逻辑特性而不指定实现细节的数据结构 ，
    简单来说就是 着重于它做了什么，而忽略它是怎么做的，栈和队列都是属于ADT，用数组或者链表都可以实现栈和队列，
    拿栈来说，它的精髓在于后进先出，在于push，pop，以及如何使用它，而不是它的内在实现，用数组还是链表实现关键就在于，
    能否精确的预测栈或队列需要容纳的数据量            
    
- 递归: 一种方法/函数调用自己的编程技术 
    - 特征:
        - 调用自身, 为了解决更小的问题
        - 存在某个足够简单的层次, 这一层次不需要调用自身就可以直接解答,并返回结果
    - 效率: 
        - 递归的调用,从调用处转移到方法的开始处,会有一定的额外开销,且中间变量和返回值也会占用系统内存    
        - 但使用递归常常是因为, 它从概念上简化了问题,而不是因为它更有效率
    - 程序设计中的递归, 类似于数学归纳法    
    - 例子: 
        - 计算三角数字,详见 MainTest.java 的 testTrangle() 方法
            - 三角数字:1,3,6,10,15,21..., 第n项的值 = 第n-1项的值 + n ;  或者说 第n项的值为从1到n的叠加
        - 计算阶乘
        - 计算n次幂
        - 计算一个单词的所用变位字,即单词的全排列    
        - 递归的二分法查找
        - 汉诺(hanoi)塔问题
    - 分治算法 : 
        - 把一个大问题分解为多个小问题,往复循环
        - 递归的二分法查找就是属于分治算法,方法中含有两个对自身的递归调用,但只有一个真的执行了
    - 消除递归:
        - 一个算法作为一个递归的方法通常从概念上很容易理解,但是,实际的运用中证明递归算法的效率不太高,
            这种情况下,把递归的算法转换成非递归的算法是非常有用的,这种转换经常会用到栈,所以实际中往往
            一开始就考虑基于栈的算法,而不是从递归的算法转化
- 树:
    - 定义:
        - 由n（n>=1）个有限节点组成一个具有层次关系的集合
        - 结合了有序数组(查找快)和链表(插入/删除快)的优点
        - 如计算机中的文件系统        
    - 边:
        - 节点由边连接,java中常用引用来表示边
    - 根: 
        - 树顶端只有一个节点,称之为根,一棵树只有一个根, 从根到其他任何节点都必须有且只有一条路径
    - 路径: 
        - 顺着连接节点的边,从一个节点到另一个节点,所经过的节点的顺序排列
    - 父节点:
        - 除根外,每个节点都有一条边向上连接到另一个节点,上面的节点称为下面节点的父节点    
    - 子节点:
        - 每个节点都可能有一条或多条边向下连接其他节点, 这些节点就称为它的子节点    
    - 叶节点:
        - 没有子节点的节点称为叶子节点,简称叶节点
    - 子树:
        - 根节点下的每个节点及其子孙节点,都可以算作一个子树
    - 访问:
        - 当程序控制流程到达某个节点,并执行某种操作,就称为访问这个节点,若只是路径经过,则不算访问
    - 遍历:
        - 按某种特定顺序访问树中所有节点
    - 层:
        - 一个节点的层数指从根节点到这个节点的距离        
    - 二叉树: 
        - 每个节点最多只能有两个子节点  , 左子节点,右子节点
        - 二叉搜索树:
            - 特征: 任何一个节点的左子节点的关键字值小于这个节点,右子节点关键字值大于等于这个父节点
    - 红黑树:
        - 解决非平衡树问题
        - 增加了某些特点的二叉搜索树 , 自平衡二叉搜索树
        - 特征:
            - 节点都有颜色(红黑,为了区分两种状态,bolean)
            - 在插入和删除的过程中,要遵顼保持这些颜色的不同排列规则,规则如下:
                1. 每个节点不是红就是黑
                2. 根总是黑色的
                3. 若节点是红色,则其子节点必须是黑色,反之到不一定必须为真
                4. 根到叶节点或空子节点的每条路径,必须包含相同数目的黑色节点(black height,黑色高度)
                (空子节点:即一个节点有左子节点没有右子节点,那么该右子节点的位置就是空子节点,有右无左亦然)
                5. 空子节点是黑色的
        - 重复关键字: 
            - 把有相同关键字的数据项分配到其他也有相同关键字数据项的两侧很重要      
            - 如40,40,40,要吧第二个40放到第一个40的右侧,第三个40放到第一个40的左侧
        - 如何修正违规的情况
            1. 改变节点的颜色
            2. 执行旋转操作,旋转必须一次做以下两件事:(左旋,右旋)
                - 使一些节点上升,一些节点下降,帮助树平衡
                - 保证不破坏二叉搜索树的特征(左小右大)    
    - 2-3-4树:
         - 多叉树,每个节点最多有4个子节点和3个数据项
         - 和红黑树一样是平衡树
         - 效率比红黑树稍差,但编程容易            
         - 通过学习2-3-4树可以更容易的理解B-树
            - B-树: 一种多叉树,专门用在外部存储(如磁盘存储器)中来组织数据
         - 234树中所有的叶节点总是在同一层上   
         - 234的含义:一个节点可能含有子节点的个数,对于非叶节点有3种可能的情况
            - 有一个数据项的节点总是有两个字节点
            - 有两个数据项的节点总是有三个子节点
            - 有三个数据项的节点总是有四个子节点
         - 叶节点没有子节点,但是可能有1,2,3个数据项,空节点是不存在的
         - 节点分裂 和 根的分裂  , 感觉234树的关键点就在于分裂 
         - 234树和红黑树: 
            - 看上去不同,但某种意义上又是完全相同的
            - 可以通过一些简单的规则相互转换,而且它们保持平衡的操作也是一样的,数学上称之为同构
            - 历史上,234树先被提出,红黑树由他发展而来
            
- 哈希表:
    - 优点:
        - 提供快速的插入和查找, 插入(有时包括删除)只需要接近常量的时间,即 O(1)
        - 编程实现相对容易
    - 缺点:
        - 基于数组,数组创建后难于扩展,某些哈希表被基本填满时,新能下降的非常严重,
        所以开发者需要清楚表中将要存储多少数据, 或者准备好定期的将数据转移到更大的哈希表中,这个过程是费时的
        - 没有一种简便的方法可以以任何一种顺序(如从小到大)遍历表中数据项,若需要这样只能选择其他数据结构
    - (若不需要有序遍历,并且可以提前预测数据量大小,那么哈希表的速度和易用性方面是无与伦比的)            
    - 关于哈希表和哈希化,一个关键点在于,如何把关键字转换成数组下标
    - 哈希算法: 
        - 将任意长度的二进制值映射为较短的固定长度的二进制值, 但是会导致多个长值对应同一个hash值,
        - 如: 将关键字值转成数组的下标值.若关键字是随机的,index = key % arraySize;
        - 折叠: 把关键字的数组分成几组,把这几组数字相加,再取余
    这就引发一个关机问题,冲突的解决. 解决的方法:
        1. 开放地址法: 通过在哈希表中再寻找一个空位解决冲突问题
            - 三种方法:
                - 线性探测: 探测下一个可用单元,会引发原始聚焦问题, 当装填因子(已填入hash表的数据项与表长的比)不太大时,聚焦分布的比较连贯
                - 二次探测: 探测相隔较远(步数的平方)的单元,而不是和原始位置相邻的单元,可以消除原始聚焦问题,但是会有二次聚焦的问题
                (因为探测序列固定.当不同关键字恰好映射到相同的数组下标时,若按照相同的探测序列寻找下一个可用单元,那么寻找到的都是一样的)
                - 再哈希法: 根据关键字使用哈希函数算出不同的步长(依赖关键字的探测序列),但要求表的容积是一个质数
                (第二个哈希函数需要具备两个特点:1.和第一个哈希函数不同; 2.不能输出0(否则将没有步长,每次探测都是原地踏步,陷入死循环))
                (例如:stepSize=constant-(key%constant))(constant是一个常数,步长的最大值)
        2. 链地址法: 在哈希表每个单元中设置链表,将数据项的关键字映射到哈希表的单元,而数据项本身插入到这个单元的链表中

- 堆:
    - 堆是一种有如下特点的二叉树
        - 堆是完全二叉树
            - 完美二叉树: 一个深度为k(>=-1)且有2^(k+1) - 1个结点的二叉树称为完美二叉树
            - 完全二叉树: 从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐
            - 完满二叉树: 所有非叶子结点的度都是2。（只要你有孩子，你就必然是有两个孩子。）
        - 堆常常用一个数组实现
        - 对的每个节点的关键字都>=这个节点的子节点的关键字(假设最大的关键字在根节点上,即降序的优先级队列)    
    - 基于堆实现的优先级队列插入删除的效率都是O(logN)
    - 堆是弱序的:
        - 与二叉搜索树相比,堆是弱序的,二叉搜索树中所有节点的左子孙节点的关键字都小于右子孙节点的关键字,
        而堆只要求沿着从根到叶子的每一条路径,节点都是有序的
    - 移除: 删除关键字最大的节点,即根节点    

- 图:
    - 从数学意义上说,树是图的一种
    - 图通常有一个固定的形状,这是由物理或抽象问题所决定的
    - 在图中,节点通常叫做顶点,连接顶点的线,叫做边
    - 邻接: 若两个顶点被同一条边连接,就称这两个顶点是邻接的
    - 路径: 边的序列
    - 连通图: 若至少有一条路径可以连接起所有顶点,那么这个图就被称作连通的
    - 非连通图: 包含几个连通子图
    - 无向图: 边没有方向,可以从任意一边到另一边       
    - 有向图: 边是单向的,如A--->B,只能从A到B,不能从B到A,就如单行道一样
    - 带权的图: 边被赋予一个权值,权值是一个数字,它能代表两个顶点间的物理距离,
        或者从一个顶点到另一个顶点的时间,或者其他任何衡量标准,如花销等
    - 不带权的图: 边没有权值的图
    - 表示图的两个方法: 
        - 邻接矩阵:
            一个N*N(N为顶点个数)的二维数组,数据项表示两点间是否存在边,有则1,无则0(或true/false)
        - 邻接表:
            一个链表数组,每个单独的链表表示了有哪些顶点与当前顶点邻接
    - 搜索图的两个方法: (最终都会到达所有连通的顶点)
        - 深度优先搜索 DFS , 通过栈实现 ,        
            - 规则1: 如果可能, 访问一个邻接的未访问的顶点,标记它, 并把它放入栈中
            - 规则2: 当不能执行规则1时, 如果栈不空,就从栈中弹出一个顶点
            - 规则3: 若不能执行规则1和2,则完成了整个搜索过程
        - 广度优先搜索 BFS , 通过队列实现
            - 规则1: 访问当前顶点的下一个未访问的邻接点(如果存在),标记为已访问,并把它插入到队列
            - 规则2: 若由于没有未访问的邻接点而不能执行规则1,则从队列头取一个顶点(如果存在),并使其为当前顶点,继续执行规则1
            - 规则3: 若由于队列为空而不能执行规则2,则搜索结束
    - 最小生成树:
        - 使用最少数量的边连接所有顶点 
        - 边的数量总比顶点数量小1  
        - 该算法可以基于深度DFS/BFS 实现
    - 有向图的拓扑排序
        - 拓扑: 研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。
            它只考虑物体间的位置关系而不考虑它们的形状和大小。
        - 拓扑排序: 是可以用图模拟的另一种操作,它可用于表示某些项目或时间必须按特定的顺序排列或发生
        - 步骤:
            1. 找到一个 没有 后继的顶点(若有一条边从A指向B,那么B就是A的后继)
            2. 从图中删除这个顶点,在列表的前面插入顶点的标记
            3. 重复1,2步骤,直到所有顶点都从图中删除,这时,列表显示的顶点顺序就是拓扑排序的结果
            (可以在其他地方存储图的数据,在拓扑排序完成后恢复他们)
        - 拓扑排序必须在 无环的有向图(有向无环图,DAG) 中进行    
            - 环:是一条路径,他的起点和终点都是同一个顶点
            - 树: 不包含环的图叫做树,如前面的二叉树等,都是这个意义上的数
         - 拓扑排序的结果并不是唯一的,可以通过调整算法得到不同的结果   
    - 关键路径分析:
        - 用图对工作进度建模(带权图)    
    - 有向图的连通性: 
        - 从一个顶点出发,能够到达那些顶点
        - 注意有向图的边是有方向的
        - 如何查找连通性:
            1. 可以使用上面的DFS算法打印出连通性表
            2. 使用Warshall算法利用图的邻接矩阵求出原图的传递闭包 
    - 有权无向图:
        - 最小生成树: 建议使用优先级队列实现        